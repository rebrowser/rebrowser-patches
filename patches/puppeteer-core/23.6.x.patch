--- a/src/cdp/Browser.ts	
+++ b/src/cdp/Browser.ts	
@@ -338,6 +338,11 @@
     return await this.#defaultContext.newPage();
   }
 
+  // rebrowser-patches: expose browser CDP session
+  _connection(): Connection {
+    return this.#connection;
+  }
+
   async _createPageInContext(contextId?: string): Promise<Page> {
     const {targetId} = await this.#connection.send('Target.createTarget', {
       url: 'about:blank',

--- a/src/cdp/ExecutionContext.ts	
+++ b/src/cdp/ExecutionContext.ts	
@@ -78,6 +78,7 @@
   #client: CDPSession;
   #world: IsolatedWorld;
   #id: number;
+  _frameId: any;
   #name?: string;
 
   readonly #disposables = new DisposableStack();
@@ -94,16 +95,22 @@
     if (contextPayload.name) {
       this.#name = contextPayload.name;
     }
+    // rebrowser-patches: keep frameId to use later
+    if (contextPayload.auxData?.frameId) {
+      this._frameId = contextPayload.auxData?.frameId;
+    }
     const clientEmitter = this.#disposables.use(new EventEmitter(this.#client));
     clientEmitter.on('Runtime.bindingCalled', this.#onBindingCalled.bind(this));
-    clientEmitter.on('Runtime.executionContextDestroyed', async event => {
-      if (event.executionContextId === this.#id) {
+    if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] === '0') {
+      clientEmitter.on('Runtime.executionContextDestroyed', async event => {
+        if (event.executionContextId === this.#id) {
+          this[disposeSymbol]();
+        }
+      });
+      clientEmitter.on('Runtime.executionContextsCleared', async () => {
         this[disposeSymbol]();
-      }
-    });
-    clientEmitter.on('Runtime.executionContextsCleared', async () => {
-      this[disposeSymbol]();
-    });
+      });
+    }
     clientEmitter.on('Runtime.consoleAPICalled', this.#onConsoleAPI.bind(this));
     clientEmitter.on(CDPSessionEvent.Disconnected, () => {
       this[disposeSymbol]();
@@ -351,6 +358,156 @@
     return await this.#evaluate(false, pageFunction, ...args);
   }
 
+  // rebrowser-patches: alternative to dispose
+  clear(newId: any) {
+    this.#id = newId
+    this.#bindings = new Map()
+    this.#bindingsInstalled = false
+    this.#puppeteerUtil = undefined
+  }
+  // rebrowser-patches: get context id if it's missing
+  async acquireContextId(tryCount = 1): Promise<any> {
+    if (this.#id > 0) {
+      return
+    }
+
+    const fixMode = process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] || 'addBinding'
+    process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] id = ${this.#id}, name = ${this.#name}, fixMode = ${fixMode}, tryCount = ${tryCount}`)
+
+    let contextId: any
+    if (fixMode === 'addBinding') {
+      try {
+        if (this.#id === -2) {
+          // isolated world
+          const sendRes = await this.#client.send('Page.createIsolatedWorld', {
+            frameId: this._frameId,
+            worldName: this.#name,
+            grantUniveralAccess: true,
+          });
+          process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] Page.createIsolatedWorld result:`, sendRes);
+          contextId = sendRes.executionContextId;
+        } else {
+          // main world
+          // random name to make it harder to detect for any 3rd party script by watching window object and events
+          const randomName = [...Array(Math.floor(Math.random() * (10 + 1)) + 10)].map(() => Math.random().toString(36)[2]).join('');
+          process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] binding name = ${randomName}`)
+
+          // add the binding
+          await this.#client.send('Runtime.addBinding', {
+            name: randomName,
+          });
+
+          // listen for 'Runtime.bindingCalled' event
+          const bindingCalledHandler = ({name, payload, executionContextId}: any) => {
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][bindingCalledHandler]', {
+              name,
+              payload,
+              executionContextId
+            });
+            if (contextId > 0) {
+              // already acquired the id
+              return;
+            }
+            if (name !== randomName) {
+              // ignore irrelevant bindings
+              return;
+            }
+            if (payload !== this._frameId) {
+              // ignore irrelevant frames
+              return;
+            }
+            contextId = executionContextId;
+            // remove this listener
+            this.#client.off('Runtime.bindingCalled', bindingCalledHandler);
+          };
+          this.#client.on('Runtime.bindingCalled', bindingCalledHandler);
+
+          // we could call the binding right from addScriptToEvaluateOnNewDocument, but this way it will be called in all existing frames and it's hard to distinguish children from the parent
+          await this.#client.send('Page.addScriptToEvaluateOnNewDocument', {
+            source: `document.addEventListener('${randomName}', (e) => self['${randomName}'](e.detail.frameId))`,
+            runImmediately: true,
+          });
+
+          // create new isolated world for this frame
+          const createIsolatedWorldRes = await this.#client.send('Page.createIsolatedWorld', {
+            frameId: this._frameId,
+            // use randomName for worldName to distinguish from normal utility world
+            worldName: randomName,
+            grantUniveralAccess: true,
+          });
+
+          // emit event in the specific frame from the isolated world
+          await this.#client.send('Runtime.evaluate', {
+            expression: `document.dispatchEvent(new CustomEvent('${randomName}', { detail: { frameId: '${this._frameId}' } }))`,
+            contextId: createIsolatedWorldRes.executionContextId,
+          })
+        }
+      } catch (error) {
+        process.env['REBROWSER_PATCHES_DEBUG'] && console.error('[rebrowser-patches][acquireContextId] error:', error)
+        if (error instanceof Error) {
+          // Missing frame
+          if (error.message.includes('No frame for given id found')) {
+            return;
+          }
+        }
+
+        debugError(error);
+      }
+    } else if (fixMode === 'alwaysIsolated') {
+      if (this.#id === -3) {
+        throw new Error('[rebrowser-patches] web workers are not supported in alwaysIsolated mode')
+      }
+
+      const sendRes = await this.#client
+        .send('Page.createIsolatedWorld', {
+          frameId: this._frameId,
+          worldName: this.#name,
+          grantUniveralAccess: true,
+        })
+      process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] Page.createIsolatedWorld result:`, sendRes)
+      contextId = sendRes.executionContextId
+    } else if (fixMode === 'enableDisable') {
+      const executionContextCreatedHandler = ({ context }: any) => {
+        process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][executionContextCreated] this.#id = ${this.#id}, name = ${this.#name}, contextId = ${contextId}, event.context.id = ${context.id}`)
+
+        if (contextId > 0) {
+          // already acquired the id
+          return
+        }
+
+        if (this.#id === -1) {
+          // main world
+          if (context.auxData && context.auxData['isDefault']) {
+            contextId = context.id
+          }
+        } else if (this.#id === -2) {
+          // utility world
+          if (this.#name === context.name) {
+            contextId = context.id
+          }
+        } else if (this.#id === -3) {
+          // web worker
+          contextId = context.id
+        }
+      }
+
+      this.#client.on('Runtime.executionContextCreated', executionContextCreatedHandler)
+      await this.#client.send('Runtime.enable')
+      await this.#client.send('Runtime.disable')
+      this.#client.off('Runtime.executionContextCreated', executionContextCreatedHandler)
+    }
+
+    if (!contextId) {
+      if (tryCount >= 3) {
+        throw new Error('[rebrowser-patches] acquireContextId failed')
+      }
+      process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] failed, try again (tryCount = ${tryCount})`)
+      return this.acquireContextId(tryCount + 1)
+    }
+
+    this.#id = contextId
+  }
+
   async #evaluate<
     Params extends unknown[],
     Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,
@@ -375,6 +532,13 @@
     pageFunction: Func | string,
     ...args: Params
   ): Promise<HandleFor<Awaited<ReturnType<Func>>> | Awaited<ReturnType<Func>>> {
+    // rebrowser-patches: context id is missing, acquire it and try again
+    if (this.#id < 0) {
+      await this.acquireContextId()
+      // @ts-ignore
+      return this.#evaluate(returnByValue, pageFunction, ...args)
+    }
+
     const sourceUrlComment = getSourceUrlComment(
       getSourcePuppeteerURLIfAvailable(pageFunction)?.toString() ??
         PuppeteerURL.INTERNAL_URL

--- a/src/cdp/FrameManager.ts	
+++ b/src/cdp/FrameManager.ts	
@@ -187,6 +187,10 @@
       this.#onFrameStoppedLoading(event.frameId);
     });
     session.on('Runtime.executionContextCreated', async event => {
+      if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+        // rebrowser-patches: ignore default logic
+        return
+      }
       await this.#frameTreeHandled?.valueOrThrow();
       this.#onExecutionContextCreated(event.context, session);
     });
@@ -212,9 +216,17 @@
           this.#frameTreeHandled?.resolve();
         }),
         client.send('Page.setLifecycleEventsEnabled', {enabled: true}),
-        client.send('Runtime.enable').then(() => {
-          return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);
-        }),
+        (() => {
+          // rebrowser-patches: skip Runtime.enable
+          if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][FrameManager] initialize')
+            return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME)
+          }
+
+          return client.send('Runtime.enable').then(() => {
+            return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);
+          })
+        })(),
         ...(frame
           ? Array.from(this.#scriptsToEvaluateOnNewDocument.values())
           : []
@@ -225,6 +237,30 @@
           return frame?.addExposedFunctionBinding(binding);
         }),
       ]);
+
+      // rebrowser-patches: manually create main world context
+      if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+        this.frames()
+          .filter(frame => {
+            return frame.client === client;
+          }).map(frame => {
+          const world = frame.worlds[MAIN_WORLD]
+          const contextPayload = {
+            id: -1,
+            name: '',
+            auxData: {
+              frameId: frame._id,
+            }
+          }
+          const context = new ExecutionContext(
+            frame.client,
+            // @ts-ignore
+            contextPayload,
+            world
+          );
+          world.setContext(context);
+        })
+      }
     } catch (error) {
       this.#frameTreeHandled?.resolve();
       // The target might have been closed before the initialization finished.
@@ -451,6 +487,24 @@
       this._frameTree.addFrame(frame);
     }
 
+    // rebrowser-patches: we cannot fully dispose contexts as they won't be recreated as we don't have Runtime events,
+    // instead, just mark it all empty
+    if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+      process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches] onFrameNavigated, navigationType = ${navigationType}, id = ${framePayload.id}, url = ${framePayload.url}`)
+      for (const worldSymbol of [MAIN_WORLD, PUPPETEER_WORLD]) {
+        // @ts-ignore
+        if (frame.worlds[worldSymbol].context) {
+          // @ts-ignore
+          const frameOrWorker = frame.worlds[worldSymbol].environment
+          if ('clearDocumentHandle' in frameOrWorker) {
+            frameOrWorker.clearDocumentHandle();
+          }
+          // @ts-ignore
+          frame.worlds[worldSymbol].context?.clear(worldSymbol === MAIN_WORLD ? -1 : -2)
+        }
+      }
+    }
+
     frame = await this._frameTree.waitForFrame(frameId);
     frame._navigated(framePayload);
     this.emit(FrameManagerEvent.FrameNavigated, frame);
@@ -483,6 +537,24 @@
               worldName: name,
               grantUniveralAccess: true,
             })
+            .then((createIsolatedWorldResult: any) => {
+              // rebrowser-patches: save created context id
+              if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] === '0') {
+                return
+              }
+              if (!createIsolatedWorldResult?.executionContextId) {
+                // probably "Target closed" error, just ignore it
+                return
+              }
+              // @ts-ignore
+              this.#onExecutionContextCreated({
+                id: createIsolatedWorldResult.executionContextId,
+                name,
+                auxData: {
+                  frameId: frame._id,
+                }
+              }, frame.client)
+            })
             .catch(debugError);
         })
     );

--- a/src/cdp/IsolatedWorld.ts	
+++ b/src/cdp/IsolatedWorld.ts	
@@ -1,3 +1,4 @@
+//@ts-nocheck
 /**
  * @license
  * Copyright 2019 Google Inc.
@@ -18,13 +19,14 @@
   fromEmitterEvent,
   timeout,
   withSourcePuppeteerURLIfNone,
+  UTILITY_WORLD_NAME,
 } from '../common/util.js';
 import {disposeSymbol} from '../util/disposable.js';
 
 import {CdpElementHandle} from './ElementHandle.js';
-import type {ExecutionContext} from './ExecutionContext.js';
+import {ExecutionContext} from './ExecutionContext.js';
 import type {CdpFrame} from './Frame.js';
-import type {MAIN_WORLD, PUPPETEER_WORLD} from './IsolatedWorlds.js';
+import {MAIN_WORLD, PUPPETEER_WORLD} from './IsolatedWorlds.js';
 import {CdpJSHandle} from './JSHandle.js';
 import type {CdpWebWorker} from './WebWorker.js';
 
@@ -136,6 +138,23 @@
    * Waits for the next context to be set on the isolated world.
    */
   async #waitForExecutionContext(): Promise<ExecutionContext> {
+    const fixMode = process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] || 'addBinding';
+    if (fixMode === 'addBinding') {
+      const isMainWorld = this.#frameOrWorker.worlds[MAIN_WORLD] === this;
+      process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][waitForExecutionContext] frameId = ${this.#frameOrWorker._id}, isMainWorld = ${isMainWorld}`);
+
+      const contextPayload = {
+        id: isMainWorld ? -1 : -2,
+        name: isMainWorld ? '' : UTILITY_WORLD_NAME,
+        auxData: {
+          frameId: this.#frameOrWorker._id,
+        }
+      };
+      const context = new ExecutionContext(this.client, contextPayload, this);
+      this.setContext(context);
+      return context;
+    }
+    
     const error = new Error('Execution context was destroyed');
     const result = await firstValueFrom(
       fromEmitterEvent(this.#emitter, 'context').pipe(
@@ -205,6 +224,8 @@
     if (!context) {
       context = await this.#waitForExecutionContext();
     }
+    // rebrowser-patches: make sure id is acquired
+    await context.acquireContextId()
     const {object} = await this.client.send('DOM.resolveNode', {
       backendNodeId: backendNodeId,
       executionContextId: context.id,

--- a/src/cdp/WebWorker.ts	
+++ b/src/cdp/WebWorker.ts	
@@ -56,6 +56,10 @@
     this.#world = new IsolatedWorld(this, new TimeoutSettings());
 
     this.#client.once('Runtime.executionContextCreated', async event => {
+      if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+        // rebrowser-patches: ignore default logic
+        return
+      }
       this.#world.setContext(
         new ExecutionContext(client, event.context, this.#world)
       );
@@ -78,8 +82,20 @@
       this.#world.dispose();
     });
 
-    // This might fail if the target is closed before we receive all execution contexts.
-    this.#client.send('Runtime.enable').catch(debugError);
+    if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+      // @ts-ignore
+      process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][WebWorker] initialize', targetType, targetId, client._target(), client._target()._getTargetInfo())
+
+      // rebrowser-patches: manually create context
+      const contextPayload = {
+        id: -3,
+      }
+      // @ts-ignore
+      this.#world.setContext(new ExecutionContext(client, contextPayload, this.#world));
+    } else {
+      // This might fail if the target is closed before we receive all execution contexts.
+      this.#client.send('Runtime.enable').catch(debugError);
+    }
   }
 
   mainRealm(): Realm {

--- a/src/common/util.ts	
+++ b/src/common/util.ts	
@@ -308,7 +308,9 @@
  * @internal
  */
 export const UTILITY_WORLD_NAME =
-  '__puppeteer_utility_world__' + packageVersion;
+  // rebrowser-patches: change utility world name
+  process.env['REBROWSER_PATCHES_UTILITY_WORLD_NAME'] !== '0' ? (process.env['REBROWSER_PATCHES_UTILITY_WORLD_NAME'] || 'util') :
+    '__puppeteer_utility_world__' + packageVersion;
 
 /**
  * @internal
@@ -319,6 +321,10 @@
  * @internal
  */
 export function getSourceUrlComment(url: string): string {
+  // rebrowser-patches: change sourceUrl to generic script name
+  if (process.env['REBROWSER_PATCHES_SOURCE_URL'] !== '0') {
+    url = process.env['REBROWSER_PATCHES_SOURCE_URL'] || 'app.js'
+  }
   return `//# sourceURL=${url}`;
 }
 

--- a/lib/cjs/puppeteer/cdp/Browser.d.ts	
+++ b/lib/cjs/puppeteer/cdp/Browser.d.ts	
@@ -31,6 +31,7 @@
     _disposeContext(contextId?: string): Promise<void>;
     wsEndpoint(): string;
     newPage(): Promise<Page>;
+    _connection(): Connection;
     _createPageInContext(contextId?: string): Promise<Page>;
     targets(): CdpTarget[];
     target(): CdpTarget;

--- a/lib/cjs/puppeteer/cdp/Browser.js	
+++ b/lib/cjs/puppeteer/cdp/Browser.js	
@@ -176,6 +176,10 @@
     async newPage() {
         return await this.#defaultContext.newPage();
     }
+    // rebrowser-patches: expose browser CDP session
+    _connection() {
+        return this.#connection;
+    }
     async _createPageInContext(contextId) {
         const { targetId } = await this.#connection.send('Target.createTarget', {
             url: 'about:blank',

--- a/lib/cjs/puppeteer/cdp/ExecutionContext.d.ts	
+++ b/lib/cjs/puppeteer/cdp/ExecutionContext.d.ts	
@@ -22,6 +22,7 @@
     bindingcalled: Protocol.Runtime.BindingCalledEvent;
 }> implements Disposable {
     #private;
+    _frameId: any;
     constructor(client: CDPSession, contextPayload: Protocol.Runtime.ExecutionContextDescription, world: IsolatedWorld);
     get id(): number;
     get puppeteerUtil(): Promise<JSHandle<PuppeteerUtil>>;
@@ -116,6 +117,8 @@
      * {@link ElementHandle | element handle}.
      */
     evaluateHandle<Params extends unknown[], Func extends EvaluateFunc<Params> = EvaluateFunc<Params>>(pageFunction: Func | string, ...args: Params): Promise<HandleFor<Awaited<ReturnType<Func>>>>;
+    clear(newId: any): void;
+    acquireContextId(tryCount?: number): Promise<any>;
     [disposeSymbol](): void;
 }
 //# sourceMappingURL=ExecutionContext.d.ts.map
\ No newline at end of file

--- a/lib/cjs/puppeteer/cdp/ExecutionContext.js	
+++ b/lib/cjs/puppeteer/cdp/ExecutionContext.js	
@@ -83,6 +83,7 @@
     #client;
     #world;
     #id;
+    _frameId;
     #name;
     #disposables = new disposable_js_1.DisposableStack();
     constructor(client, contextPayload, world) {
@@ -93,16 +94,22 @@
         if (contextPayload.name) {
             this.#name = contextPayload.name;
         }
+        // rebrowser-patches: keep frameId to use later
+        if (contextPayload.auxData?.frameId) {
+            this._frameId = contextPayload.auxData?.frameId;
+        }
         const clientEmitter = this.#disposables.use(new EventEmitter_js_1.EventEmitter(this.#client));
         clientEmitter.on('Runtime.bindingCalled', this.#onBindingCalled.bind(this));
-        clientEmitter.on('Runtime.executionContextDestroyed', async (event) => {
-            if (event.executionContextId === this.#id) {
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] === '0') {
+            clientEmitter.on('Runtime.executionContextDestroyed', async (event) => {
+                if (event.executionContextId === this.#id) {
+                    this[disposable_js_1.disposeSymbol]();
+                }
+            });
+            clientEmitter.on('Runtime.executionContextsCleared', async () => {
                 this[disposable_js_1.disposeSymbol]();
-            }
-        });
-        clientEmitter.on('Runtime.executionContextsCleared', async () => {
-            this[disposable_js_1.disposeSymbol]();
-        });
+            });
+        }
         clientEmitter.on('Runtime.consoleAPICalled', this.#onConsoleAPI.bind(this));
         clientEmitter.on(CDPSession_js_1.CDPSessionEvent.Disconnected, () => {
             this[disposable_js_1.disposeSymbol]();
@@ -326,7 +333,154 @@
     async evaluateHandle(pageFunction, ...args) {
         return await this.#evaluate(false, pageFunction, ...args);
     }
+    // rebrowser-patches: alternative to dispose
+    clear(newId) {
+        this.#id = newId;
+        this.#bindings = new Map();
+        this.#bindingsInstalled = false;
+        this.#puppeteerUtil = undefined;
+    }
+    // rebrowser-patches: get context id if it's missing
+    async acquireContextId(tryCount = 1) {
+        if (this.#id > 0) {
+            return;
+        }
+        const fixMode = process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] || 'addBinding';
+        process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] id = ${this.#id}, name = ${this.#name}, fixMode = ${fixMode}, tryCount = ${tryCount}`);
+        let contextId;
+        if (fixMode === 'addBinding') {
+            try {
+                if (this.#id === -2) {
+                    // isolated world
+                    const sendRes = await this.#client.send('Page.createIsolatedWorld', {
+                        frameId: this._frameId,
+                        worldName: this.#name,
+                        grantUniveralAccess: true,
+                    });
+                    process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] Page.createIsolatedWorld result:`, sendRes);
+                    contextId = sendRes.executionContextId;
+                }
+                else {
+                    // main world
+                    // random name to make it harder to detect for any 3rd party script by watching window object and events
+                    const randomName = [...Array(Math.floor(Math.random() * (10 + 1)) + 10)].map(() => Math.random().toString(36)[2]).join('');
+                    process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] binding name = ${randomName}`);
+                    // add the binding
+                    await this.#client.send('Runtime.addBinding', {
+                        name: randomName,
+                    });
+                    // listen for 'Runtime.bindingCalled' event
+                    const bindingCalledHandler = ({ name, payload, executionContextId }) => {
+                        process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][bindingCalledHandler]', {
+                            name,
+                            payload,
+                            executionContextId
+                        });
+                        if (contextId > 0) {
+                            // already acquired the id
+                            return;
+                        }
+                        if (name !== randomName) {
+                            // ignore irrelevant bindings
+                            return;
+                        }
+                        if (payload !== this._frameId) {
+                            // ignore irrelevant frames
+                            return;
+                        }
+                        contextId = executionContextId;
+                        // remove this listener
+                        this.#client.off('Runtime.bindingCalled', bindingCalledHandler);
+                    };
+                    this.#client.on('Runtime.bindingCalled', bindingCalledHandler);
+                    // we could call the binding right from addScriptToEvaluateOnNewDocument, but this way it will be called in all existing frames and it's hard to distinguish children from the parent
+                    await this.#client.send('Page.addScriptToEvaluateOnNewDocument', {
+                        source: `document.addEventListener('${randomName}', (e) => self['${randomName}'](e.detail.frameId))`,
+                        runImmediately: true,
+                    });
+                    // create new isolated world for this frame
+                    const createIsolatedWorldRes = await this.#client.send('Page.createIsolatedWorld', {
+                        frameId: this._frameId,
+                        // use randomName for worldName to distinguish from normal utility world
+                        worldName: randomName,
+                        grantUniveralAccess: true,
+                    });
+                    // emit event in the specific frame from the isolated world
+                    await this.#client.send('Runtime.evaluate', {
+                        expression: `document.dispatchEvent(new CustomEvent('${randomName}', { detail: { frameId: '${this._frameId}' } }))`,
+                        contextId: createIsolatedWorldRes.executionContextId,
+                    });
+                }
+            }
+            catch (error) {
+                process.env['REBROWSER_PATCHES_DEBUG'] && console.error('[rebrowser-patches][acquireContextId] error:', error);
+                if (error instanceof Error) {
+                    // Missing frame
+                    if (error.message.includes('No frame for given id found')) {
+                        return;
+                    }
+                }
+                (0, util_js_1.debugError)(error);
+            }
+        }
+        else if (fixMode === 'alwaysIsolated') {
+            if (this.#id === -3) {
+                throw new Error('[rebrowser-patches] web workers are not supported in alwaysIsolated mode');
+            }
+            const sendRes = await this.#client
+                .send('Page.createIsolatedWorld', {
+                frameId: this._frameId,
+                worldName: this.#name,
+                grantUniveralAccess: true,
+            });
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] Page.createIsolatedWorld result:`, sendRes);
+            contextId = sendRes.executionContextId;
+        }
+        else if (fixMode === 'enableDisable') {
+            const executionContextCreatedHandler = ({ context }) => {
+                process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][executionContextCreated] this.#id = ${this.#id}, name = ${this.#name}, contextId = ${contextId}, event.context.id = ${context.id}`);
+                if (contextId > 0) {
+                    // already acquired the id
+                    return;
+                }
+                if (this.#id === -1) {
+                    // main world
+                    if (context.auxData && context.auxData['isDefault']) {
+                        contextId = context.id;
+                    }
+                }
+                else if (this.#id === -2) {
+                    // utility world
+                    if (this.#name === context.name) {
+                        contextId = context.id;
+                    }
+                }
+                else if (this.#id === -3) {
+                    // web worker
+                    contextId = context.id;
+                }
+            };
+            this.#client.on('Runtime.executionContextCreated', executionContextCreatedHandler);
+            await this.#client.send('Runtime.enable');
+            await this.#client.send('Runtime.disable');
+            this.#client.off('Runtime.executionContextCreated', executionContextCreatedHandler);
+        }
+        if (!contextId) {
+            if (tryCount >= 3) {
+                throw new Error('[rebrowser-patches] acquireContextId failed');
+            }
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] failed, try again (tryCount = ${tryCount})`);
+            return this.acquireContextId(tryCount + 1);
+        }
+        this.#id = contextId;
+    }
     async #evaluate(returnByValue, pageFunction, ...args) {
+        // rebrowser-patches: context id is missing, acquire it and try again
+        if (this.#id < 0) {
+            await this.acquireContextId();
+            // @ts-ignore
+            return this.#evaluate(returnByValue, pageFunction, ...args);
+        }
         const sourceUrlComment = (0, util_js_1.getSourceUrlComment)((0, util_js_1.getSourcePuppeteerURLIfAvailable)(pageFunction)?.toString() ??
             util_js_1.PuppeteerURL.INTERNAL_URL);
         if ((0, util_js_1.isString)(pageFunction)) {

--- a/lib/cjs/puppeteer/cdp/FrameManager.js	
+++ b/lib/cjs/puppeteer/cdp/FrameManager.js	
@@ -150,6 +150,10 @@
             this.#onFrameStoppedLoading(event.frameId);
         });
         session.on('Runtime.executionContextCreated', async (event) => {
+            if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+                // rebrowser-patches: ignore default logic
+                return;
+            }
             await this.#frameTreeHandled?.valueOrThrow();
             this.#onExecutionContextCreated(event.context, session);
         });
@@ -174,9 +178,16 @@
                     this.#frameTreeHandled?.resolve();
                 }),
                 client.send('Page.setLifecycleEventsEnabled', { enabled: true }),
-                client.send('Runtime.enable').then(() => {
-                    return this.#createIsolatedWorld(client, util_js_1.UTILITY_WORLD_NAME);
-                }),
+                (() => {
+                    // rebrowser-patches: skip Runtime.enable
+                    if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+                        process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][FrameManager] initialize');
+                        return this.#createIsolatedWorld(client, util_js_1.UTILITY_WORLD_NAME);
+                    }
+                    return client.send('Runtime.enable').then(() => {
+                        return this.#createIsolatedWorld(client, util_js_1.UTILITY_WORLD_NAME);
+                    });
+                })(),
                 ...(frame
                     ? Array.from(this.#scriptsToEvaluateOnNewDocument.values())
                     : []).map(script => {
@@ -186,6 +197,26 @@
                     return frame?.addExposedFunctionBinding(binding);
                 }),
             ]);
+            // rebrowser-patches: manually create main world context
+            if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+                this.frames()
+                    .filter(frame => {
+                    return frame.client === client;
+                }).map(frame => {
+                    const world = frame.worlds[IsolatedWorlds_js_1.MAIN_WORLD];
+                    const contextPayload = {
+                        id: -1,
+                        name: '',
+                        auxData: {
+                            frameId: frame._id,
+                        }
+                    };
+                    const context = new ExecutionContext_js_1.ExecutionContext(frame.client, 
+                    // @ts-ignore
+                    contextPayload, world);
+                    world.setContext(context);
+                });
+            }
         }
         catch (error) {
             this.#frameTreeHandled?.resolve();
@@ -354,6 +385,23 @@
             }
             this._frameTree.addFrame(frame);
         }
+        // rebrowser-patches: we cannot fully dispose contexts as they won't be recreated as we don't have Runtime events,
+        // instead, just mark it all empty
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches] onFrameNavigated, navigationType = ${navigationType}, id = ${framePayload.id}, url = ${framePayload.url}`);
+            for (const worldSymbol of [IsolatedWorlds_js_1.MAIN_WORLD, IsolatedWorlds_js_1.PUPPETEER_WORLD]) {
+                // @ts-ignore
+                if (frame.worlds[worldSymbol].context) {
+                    // @ts-ignore
+                    const frameOrWorker = frame.worlds[worldSymbol].environment;
+                    if ('clearDocumentHandle' in frameOrWorker) {
+                        frameOrWorker.clearDocumentHandle();
+                    }
+                    // @ts-ignore
+                    frame.worlds[worldSymbol].context?.clear(worldSymbol === IsolatedWorlds_js_1.MAIN_WORLD ? -1 : -2);
+                }
+            }
+        }
         frame = await this._frameTree.waitForFrame(frameId);
         frame._navigated(framePayload);
         this.emit(FrameManagerEvents_js_1.FrameManagerEvent.FrameNavigated, frame);
@@ -381,6 +429,24 @@
                 worldName: name,
                 grantUniveralAccess: true,
             })
+                .then((createIsolatedWorldResult) => {
+                // rebrowser-patches: save created context id
+                if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] === '0') {
+                    return;
+                }
+                if (!createIsolatedWorldResult?.executionContextId) {
+                    // probably "Target closed" error, just ignore it
+                    return;
+                }
+                // @ts-ignore
+                this.#onExecutionContextCreated({
+                    id: createIsolatedWorldResult.executionContextId,
+                    name,
+                    auxData: {
+                        frameId: frame._id,
+                    }
+                }, frame.client);
+            })
                 .catch(util_js_1.debugError);
         }));
         this.#isolatedWorlds.add(key);

--- a/lib/cjs/puppeteer/cdp/IsolatedWorld.d.ts	
+++ b/lib/cjs/puppeteer/cdp/IsolatedWorld.d.ts	
@@ -12,9 +12,9 @@
 import type { TimeoutSettings } from '../common/TimeoutSettings.js';
 import type { EvaluateFunc, HandleFor } from '../common/types.js';
 import { disposeSymbol } from '../util/disposable.js';
-import type { ExecutionContext } from './ExecutionContext.js';
+import { ExecutionContext } from './ExecutionContext.js';
 import type { CdpFrame } from './Frame.js';
-import type { MAIN_WORLD, PUPPETEER_WORLD } from './IsolatedWorlds.js';
+import { MAIN_WORLD, PUPPETEER_WORLD } from './IsolatedWorlds.js';
 import type { CdpWebWorker } from './WebWorker.js';
 /**
  * @internal

--- a/lib/cjs/puppeteer/cdp/IsolatedWorld.js	
+++ b/lib/cjs/puppeteer/cdp/IsolatedWorld.js	
@@ -1,4 +1,5 @@
 "use strict";
+//@ts-nocheck
 /**
  * @license
  * Copyright 2019 Google Inc.
@@ -12,6 +13,8 @@
 const util_js_1 = require("../common/util.js");
 const disposable_js_1 = require("../util/disposable.js");
 const ElementHandle_js_1 = require("./ElementHandle.js");
+const ExecutionContext_js_1 = require("./ExecutionContext.js");
+const IsolatedWorlds_js_1 = require("./IsolatedWorlds.js");
 const JSHandle_js_1 = require("./JSHandle.js");
 /**
  * @internal
@@ -70,6 +73,21 @@
      * Waits for the next context to be set on the isolated world.
      */
     async #waitForExecutionContext() {
+        const fixMode = process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] || 'addBinding';
+        if (fixMode === 'addBinding') {
+            const isMainWorld = this.#frameOrWorker.worlds[IsolatedWorlds_js_1.MAIN_WORLD] === this;
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][waitForExecutionContext] frameId = ${this.#frameOrWorker._id}, isMainWorld = ${isMainWorld}`);
+            const contextPayload = {
+                id: isMainWorld ? -1 : -2,
+                name: isMainWorld ? '' : util_js_1.UTILITY_WORLD_NAME,
+                auxData: {
+                    frameId: this.#frameOrWorker._id,
+                }
+            };
+            const context = new ExecutionContext_js_1.ExecutionContext(this.client, contextPayload, this);
+            this.setContext(context);
+            return context;
+        }
         const error = new Error('Execution context was destroyed');
         const result = await (0, rxjs_js_1.firstValueFrom)((0, util_js_1.fromEmitterEvent)(this.#emitter, 'context').pipe((0, rxjs_js_1.raceWith)((0, util_js_1.fromEmitterEvent)(this.#emitter, 'disposed').pipe((0, rxjs_js_1.map)(() => {
             // The message has to match the CDP message expected by the WaitTask class.
@@ -107,6 +125,8 @@
         if (!context) {
             context = await this.#waitForExecutionContext();
         }
+        // rebrowser-patches: make sure id is acquired
+        await context.acquireContextId();
         const { object } = await this.client.send('DOM.resolveNode', {
             backendNodeId: backendNodeId,
             executionContextId: context.id,

--- a/lib/cjs/puppeteer/cdp/WebWorker.js	
+++ b/lib/cjs/puppeteer/cdp/WebWorker.js	
@@ -24,6 +24,10 @@
         this.#targetType = targetType;
         this.#world = new IsolatedWorld_js_1.IsolatedWorld(this, new TimeoutSettings_js_1.TimeoutSettings());
         this.#client.once('Runtime.executionContextCreated', async (event) => {
+            if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+                // rebrowser-patches: ignore default logic
+                return;
+            }
             this.#world.setContext(new ExecutionContext_js_1.ExecutionContext(client, event.context, this.#world));
         });
         this.#world.emitter.on('consoleapicalled', async (event) => {
@@ -40,8 +44,20 @@
         this.#client.once(CDPSession_js_1.CDPSessionEvent.Disconnected, () => {
             this.#world.dispose();
         });
-        // This might fail if the target is closed before we receive all execution contexts.
-        this.#client.send('Runtime.enable').catch(util_js_1.debugError);
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+            // @ts-ignore
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][WebWorker] initialize', targetType, targetId, client._target(), client._target()._getTargetInfo());
+            // rebrowser-patches: manually create context
+            const contextPayload = {
+                id: -3,
+            };
+            // @ts-ignore
+            this.#world.setContext(new ExecutionContext_js_1.ExecutionContext(client, contextPayload, this.#world));
+        }
+        else {
+            // This might fail if the target is closed before we receive all execution contexts.
+            this.#client.send('Runtime.enable').catch(util_js_1.debugError);
+        }
     }
     mainRealm() {
         return this.#world;

--- a/lib/cjs/puppeteer/common/util.js	
+++ b/lib/cjs/puppeteer/common/util.js	
@@ -259,7 +259,10 @@
 /**
  * @internal
  */
-exports.UTILITY_WORLD_NAME = '__puppeteer_utility_world__' + version_js_1.packageVersion;
+exports.UTILITY_WORLD_NAME = 
+// rebrowser-patches: change utility world name
+process.env['REBROWSER_PATCHES_UTILITY_WORLD_NAME'] !== '0' ? (process.env['REBROWSER_PATCHES_UTILITY_WORLD_NAME'] || 'util') :
+    '__puppeteer_utility_world__' + version_js_1.packageVersion;
 /**
  * @internal
  */
@@ -268,6 +271,10 @@
  * @internal
  */
 function getSourceUrlComment(url) {
+    // rebrowser-patches: change sourceUrl to generic script name
+    if (process.env['REBROWSER_PATCHES_SOURCE_URL'] !== '0') {
+        url = process.env['REBROWSER_PATCHES_SOURCE_URL'] || 'app.js';
+    }
     return `//# sourceURL=${url}`;
 }
 /**

--- a/lib/es5-iife/puppeteer-core-browser.js	
+++ b/lib/es5-iife/puppeteer-core-browser.js	
@@ -186,7 +186,7 @@
    limitations under the License.
    
    */
-  // node_modules/tslib/tslib.es6.mjs
+  // lib/esm/third_party/rxjs/rxjs.js
   var extendStatics = function (d, b) {
     extendStatics = Object.setPrototypeOf || {
       
@@ -428,13 +428,9 @@
       }, reject);
     }
   }
-
-  // node_modules/rxjs/dist/esm5/internal/util/isFunction.js
   function isFunction(value) {
     return typeof value === "function";
   }
-
-  // node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
   function createErrorClass(createImpl) {
     var _super = function (instance) {
       Error.call(instance);
@@ -445,8 +441,6 @@
     ctorFunc.prototype.constructor = ctorFunc;
     return ctorFunc;
   }
-
-  // node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
   var UnsubscriptionError = createErrorClass(function (_super) {
     return function UnsubscriptionErrorImpl(errors) {
       _super(this);
@@ -457,16 +451,12 @@
       this.errors = errors;
     };
   });
-
-  // node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
   function arrRemove(arr, item) {
     if (arr) {
       var index = arr.indexOf(item);
       0 <= index && arr.splice(index, 1);
     }
   }
-
-  // node_modules/rxjs/dist/esm5/internal/Subscription.js
   var Subscription = function () {
     function Subscription2(initialTeardown) {
       this.initialTeardown = initialTeardown;
@@ -602,8 +592,6 @@
       finalizer.unsubscribe();
     }
   }
-
-  // node_modules/rxjs/dist/esm5/internal/config.js
   var config = {
     onUnhandledError: null,
     onStoppedNotification: null,
@@ -611,8 +599,6 @@
     useDeprecatedSynchronousErrorHandling: false,
     useDeprecatedNextContext: false
   };
-
-  // node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
   var timeoutProvider = {
     setTimeout: function (handler, timeout) {
       var args = [];
@@ -626,8 +612,6 @@
     },
     delegate: void 0
   };
-
-  // node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
   function reportUnhandledError(err) {
     timeoutProvider.setTimeout(function () {
       {
@@ -635,16 +619,12 @@
       }
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/util/noop.js
   function noop() {}
   function errorContext(cb) {
     {
       cb();
     }
   }
-
-  // node_modules/rxjs/dist/esm5/internal/Subscriber.js
   var Subscriber = function (_super) {
     __extends(Subscriber2, _super);
     function Subscriber2(destination) {
@@ -794,18 +774,12 @@
     error: defaultErrorHandler,
     complete: noop
   };
-
-  // node_modules/rxjs/dist/esm5/internal/symbol/observable.js
   var observable = function () {
     return typeof Symbol === "function" && Symbol.observable || "@@observable";
   }();
-
-  // node_modules/rxjs/dist/esm5/internal/util/identity.js
   function identity(x) {
     return x;
   }
-
-  // node_modules/rxjs/dist/esm5/internal/util/pipe.js
   function pipe() {
     var fns = [];
     for (var _i = 0; _i < arguments.length; _i++) {
@@ -826,8 +800,6 @@
       }, input);
     };
   }
-
-  // node_modules/rxjs/dist/esm5/internal/Observable.js
   var Observable = function () {
     function Observable2(subscribe) {
       if (subscribe) {
@@ -920,8 +892,6 @@
   function isSubscriber(value) {
     return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
   }
-
-  // node_modules/rxjs/dist/esm5/internal/util/lift.js
   function hasLift(source) {
     return isFunction(source === null || source === void 0 ? void 0 : source.lift);
   }
@@ -939,8 +909,6 @@
       throw new TypeError("Unable to lift unknown Observable type");
     };
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
   function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
     return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
   }
@@ -987,8 +955,6 @@
     };
     return OperatorSubscriber2;
   }(Subscriber);
-
-  // node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
   var ObjectUnsubscribedError = createErrorClass(function (_super) {
     return function ObjectUnsubscribedErrorImpl() {
       _super(this);
@@ -996,8 +962,6 @@
       this.message = "object unsubscribed";
     };
   });
-
-  // node_modules/rxjs/dist/esm5/internal/Subject.js
   var Subject = function (_super) {
     __extends(Subject2, _super);
     function Subject2() {
@@ -1159,16 +1123,12 @@
     };
     return AnonymousSubject2;
   }(Subject);
-
-  // node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
   var dateTimestampProvider = {
     now: function () {
       return (dateTimestampProvider.delegate || Date).now();
     },
     delegate: void 0
   };
-
-  // node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
   var ReplaySubject = function (_super) {
     __extends(ReplaySubject2, _super);
     function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
@@ -1239,8 +1199,6 @@
     };
     return ReplaySubject2;
   }(Subject);
-
-  // node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
   var Action = function (_super) {
     __extends(Action2, _super);
     function Action2(scheduler, work) {
@@ -1251,8 +1209,6 @@
     };
     return Action2;
   }(Subscription);
-
-  // node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
   var intervalProvider = {
     setInterval: function (handler, timeout) {
       var args = [];
@@ -1266,8 +1222,6 @@
     },
     delegate: void 0
   };
-
-  // node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
   var AsyncAction = function (_super) {
     __extends(AsyncAction2, _super);
     function AsyncAction2(scheduler, work) {
@@ -1358,8 +1312,6 @@
     };
     return AsyncAction2;
   }(Action);
-
-  // node_modules/rxjs/dist/esm5/internal/Scheduler.js
   var Scheduler = function () {
     function Scheduler2(schedulerActionCtor, now) {
       if (now === void 0) {
@@ -1377,8 +1329,6 @@
     Scheduler2.now = dateTimestampProvider.now;
     return Scheduler2;
   }();
-
-  // node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
   var AsyncScheduler = function (_super) {
     __extends(AsyncScheduler2, _super);
     function AsyncScheduler2(SchedulerAction, now) {
@@ -1413,22 +1363,14 @@
     };
     return AsyncScheduler2;
   }(Scheduler);
-
-  // node_modules/rxjs/dist/esm5/internal/scheduler/async.js
   var asyncScheduler = new AsyncScheduler(AsyncAction);
   var async = asyncScheduler;
-
-  // node_modules/rxjs/dist/esm5/internal/observable/empty.js
   var EMPTY = new Observable(function (subscriber) {
     return subscriber.complete();
   });
-
-  // node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
   function isScheduler(value) {
     return value && isFunction(value.schedule);
   }
-
-  // node_modules/rxjs/dist/esm5/internal/util/args.js
   function last(arr) {
     return arr[arr.length - 1];
   }
@@ -1438,33 +1380,21 @@
   function popNumber(args, defaultValue) {
     return typeof last(args) === "number" ? args.pop() : defaultValue;
   }
-
-  // node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
   var isArrayLike = function (x) {
     return x && typeof x.length === "number" && typeof x !== "function";
   };
-
-  // node_modules/rxjs/dist/esm5/internal/util/isPromise.js
   function isPromise(value) {
     return isFunction(value === null || value === void 0 ? void 0 : value.then);
   }
-
-  // node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
   function isInteropObservable(input) {
     return isFunction(input[observable]);
   }
-
-  // node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
   function isAsyncIterable(obj) {
     return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
   }
-
-  // node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
   function createInvalidObservableTypeError(input) {
     return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
   }
-
-  // node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
   function getSymbolIterator() {
     if (typeof Symbol !== "function" || !Symbol.iterator) {
       return "@@iterator";
@@ -1472,13 +1402,9 @@
     return Symbol.iterator;
   }
   var iterator = getSymbolIterator();
-
-  // node_modules/rxjs/dist/esm5/internal/util/isIterable.js
   function isIterable(input) {
     return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
   }
-
-  // node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
   function readableStreamLikeToAsyncGenerator(readableStream) {
     return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
       var reader, _a, value, done;
@@ -1519,8 +1445,6 @@
   function isReadableStreamLike(obj) {
     return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
   }
-
-  // node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
   function innerFrom(input) {
     if (input instanceof Observable) {
       return input;
@@ -1663,8 +1587,6 @@
       });
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
   function executeSchedule(parentSubscription, scheduler, work, delay2, repeat) {
     if (delay2 === void 0) {
       delay2 = 0;
@@ -1685,8 +1607,6 @@
       return scheduleSubscription;
     }
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
   function observeOn(scheduler, delay2) {
     if (delay2 === void 0) {
       delay2 = 0;
@@ -1707,8 +1627,6 @@
       }));
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
   function subscribeOn(scheduler, delay2) {
     if (delay2 === void 0) {
       delay2 = 0;
@@ -1719,18 +1637,12 @@
       }, delay2));
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
   function scheduleObservable(input, scheduler) {
     return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
   }
-
-  // node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
   function schedulePromise(input, scheduler) {
     return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
   }
-
-  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
   function scheduleArray(input, scheduler) {
     return new Observable(function (subscriber) {
       var i = 0;
@@ -1746,8 +1658,6 @@
       });
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
   function scheduleIterable(input, scheduler) {
     return new Observable(function (subscriber) {
       var iterator2;
@@ -1775,8 +1685,6 @@
       };
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
   function scheduleAsyncIterable(input, scheduler) {
     if (!input) {
       throw new Error("Iterable cannot be null");
@@ -1796,13 +1704,9 @@
       });
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
   function scheduleReadableStreamLike(input, scheduler) {
     return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
   }
-
-  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
   function scheduled(input, scheduler) {
     if (input != null) {
       if (isInteropObservable(input)) {
@@ -1826,13 +1730,9 @@
     }
     throw createInvalidObservableTypeError(input);
   }
-
-  // node_modules/rxjs/dist/esm5/internal/observable/from.js
   function from(input, scheduler) {
     return scheduler ? scheduled(input, scheduler) : innerFrom(input);
   }
-
-  // node_modules/rxjs/dist/esm5/internal/observable/of.js
   function of() {
     var args = [];
     for (var _i = 0; _i < arguments.length; _i++) {
@@ -1841,8 +1741,6 @@
     var scheduler = popScheduler(args);
     return from(args, scheduler);
   }
-
-  // node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
   var EmptyError = createErrorClass(function (_super) {
     return function EmptyErrorImpl() {
       _super(this);
@@ -1850,8 +1748,6 @@
       this.message = "no elements in sequence";
     };
   });
-
-  // node_modules/rxjs/dist/esm5/internal/firstValueFrom.js
   function firstValueFrom(source, config2) {
     return new Promise(function (resolve, reject) {
       var subscriber = new SafeSubscriber({
@@ -1869,13 +1765,9 @@
       source.subscribe(subscriber);
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/util/isDate.js
   function isValidDate(value) {
     return value instanceof Date && !isNaN(value);
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/map.js
   function map(project, thisArg) {
     return operate(function (source, subscriber) {
       var index = 0;
@@ -1884,8 +1776,6 @@
       }));
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
   var isArray = Array.isArray;
   function callOrApply(fn, args) {
     return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
@@ -1895,8 +1785,6 @@
       return callOrApply(fn, args);
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
   function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
     var buffer = [];
     var active = 0;
@@ -1951,8 +1839,6 @@
       additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
     };
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
   function mergeMap(project, resultSelector, concurrent) {
     if (concurrent === void 0) {
       concurrent = Infinity;
@@ -1970,21 +1856,15 @@
       return mergeInternals(source, subscriber, project, concurrent);
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
   function mergeAll(concurrent) {
     if (concurrent === void 0) {
       concurrent = Infinity;
     }
     return mergeMap(identity, concurrent);
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
   function concatAll() {
     return mergeAll(1);
   }
-
-  // node_modules/rxjs/dist/esm5/internal/observable/concat.js
   function concat() {
     var args = [];
     for (var _i = 0; _i < arguments.length; _i++) {
@@ -1992,15 +1872,11 @@
     }
     return concatAll()(from(args, popScheduler(args)));
   }
-
-  // node_modules/rxjs/dist/esm5/internal/observable/defer.js
   function defer(observableFactory) {
     return new Observable(function (subscriber) {
       innerFrom(observableFactory()).subscribe(subscriber);
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js
   var nodeEventEmitterMethods = ["addListener", "removeListener"];
   var eventTargetMethods = ["addEventListener", "removeEventListener"];
   var jqueryMethods = ["on", "off"];
@@ -2059,8 +1935,6 @@
   function isEventTarget(target) {
     return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
   }
-
-  // node_modules/rxjs/dist/esm5/internal/observable/timer.js
   function timer(dueTime, intervalOrScheduler, scheduler) {
     if (dueTime === void 0) {
       dueTime = 0;
@@ -2084,8 +1958,6 @@
       }, due);
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/observable/merge.js
   function merge() {
     var args = [];
     for (var _i = 0; _i < arguments.length; _i++) {
@@ -2096,17 +1968,11 @@
     var sources = args;
     return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
   }
-
-  // node_modules/rxjs/dist/esm5/internal/observable/never.js
   var NEVER = new Observable(noop);
-
-  // node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
   var isArray3 = Array.isArray;
   function argsOrArgArray(args) {
     return args.length === 1 && isArray3(args[0]) ? args[0] : args;
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/filter.js
   function filter(predicate, thisArg) {
     return operate(function (source, subscriber) {
       var index = 0;
@@ -2115,8 +1981,6 @@
       }));
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/observable/race.js
   function race() {
     var sources = [];
     for (var _i = 0; _i < arguments.length; _i++) {
@@ -2144,8 +2008,6 @@
       }
     };
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/catchError.js
   function catchError(selector) {
     return operate(function (source, subscriber) {
       var innerSub = null;
@@ -2168,8 +2030,6 @@
       }
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js
   function defaultIfEmpty(defaultValue) {
     return operate(function (source, subscriber) {
       var hasValue = false;
@@ -2184,8 +2044,6 @@
       }));
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/take.js
   function take(count) {
     return count <= 0 ? function () {
       return EMPTY;
@@ -2201,15 +2059,11 @@
       }));
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/ignoreElements.js
   function ignoreElements() {
     return operate(function (source, subscriber) {
       source.subscribe(createOperatorSubscriber(subscriber, noop));
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js
   function throwIfEmpty(errorFactory) {
     if (errorFactory === void 0) {
       errorFactory = defaultErrorFactory;
@@ -2227,8 +2081,6 @@
   function defaultErrorFactory() {
     return new EmptyError();
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/first.js
   function first(predicate, defaultValue) {
     var hasDefaultValue = arguments.length >= 2;
     return function (source) {
@@ -2239,8 +2091,6 @@
       }));
     };
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/mergeScan.js
   function mergeScan(accumulator, seed, concurrent) {
     if (concurrent === void 0) {
       concurrent = Infinity;
@@ -2256,8 +2106,6 @@
       });
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/raceWith.js
   function raceWith() {
     var otherSources = [];
     for (var _i = 0; _i < arguments.length; _i++) {
@@ -2267,8 +2115,6 @@
       raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/retry.js
   function retry(configOrCount) {
     if (configOrCount === void 0) {
       configOrCount = Infinity;
@@ -2332,8 +2178,6 @@
       subscribeForRetry();
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/startWith.js
   function startWith() {
     var values = [];
     for (var _i = 0; _i < arguments.length; _i++) {
@@ -2344,8 +2188,6 @@
       (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
   function switchMap(project, resultSelector) {
     return operate(function (source, subscriber) {
       var innerSubscriber = null;
@@ -2370,8 +2212,6 @@
       }));
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js
   function takeUntil(notifier) {
     return operate(function (source, subscriber) {
       innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function () {
@@ -2380,8 +2220,6 @@
       !subscriber.closed && source.subscribe(subscriber);
     });
   }
-
-  // node_modules/rxjs/dist/esm5/internal/operators/tap.js
   function tap(observerOrNext, error, complete) {
     var tapObserver = isFunction(observerOrNext) || error || complete ? {
       next: observerOrNext,
@@ -2435,7 +2273,7 @@
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
    */
-  // ../../node_modules/mitt/dist/mitt.mjs
+  // lib/esm/third_party/mitt/mitt.js
   function mitt_default(n) {
     return {
       all: n = n || /* @__PURE__ */new Map(),
@@ -3415,7 +3253,9 @@
   /**
    * @internal
    */
-  const UTILITY_WORLD_NAME = '__puppeteer_utility_world__' + packageVersion;
+  const UTILITY_WORLD_NAME =
+  // rebrowser-patches: change utility world name
+  process.env['REBROWSER_PATCHES_UTILITY_WORLD_NAME'] !== '0' ? process.env['REBROWSER_PATCHES_UTILITY_WORLD_NAME'] || 'util' : '__puppeteer_utility_world__' + packageVersion;
   /**
    * @internal
    */
@@ -3424,6 +3264,10 @@
    * @internal
    */
   function getSourceUrlComment(url) {
+    // rebrowser-patches: change sourceUrl to generic script name
+    if (process.env['REBROWSER_PATCHES_SOURCE_URL'] !== '0') {
+      url = process.env['REBROWSER_PATCHES_SOURCE_URL'] || 'app.js';
+    }
     return `//# sourceURL=${url}`;
   }
   /**
@@ -4983,7 +4827,7 @@
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
    */
-  // ../../node_modules/parsel-js/dist/parsel.js
+  // lib/esm/third_party/parsel-js/parsel-js.js
   _defineProperty(PQueryHandler, "querySelectorAll", (element, selector, {
     pQuerySelectorAll
   }) => {
@@ -15440,6 +15284,7 @@
       _classPrivateFieldInitSpec(this, _client8, void 0);
       _classPrivateFieldInitSpec(this, _world3, void 0);
       _classPrivateFieldInitSpec(this, _id6, void 0);
+      _defineProperty(this, "_frameId", void 0);
       _classPrivateFieldInitSpec(this, _name3, void 0);
       _classPrivateFieldInitSpec(this, _disposables, new DisposableStack());
       // Contains mapping from functions that should be bound to Puppeteer functions.
@@ -15455,16 +15300,22 @@
       if (contextPayload.name) {
         _classPrivateFieldSet(_name3, this, contextPayload.name);
       }
+      // rebrowser-patches: keep frameId to use later
+      if (contextPayload.auxData?.frameId) {
+        this._frameId = contextPayload.auxData?.frameId;
+      }
       const clientEmitter = _classPrivateFieldGet(_disposables, this).use(new EventEmitter(_classPrivateFieldGet(_client8, this)));
       clientEmitter.on('Runtime.bindingCalled', _assertClassBrand(_ExecutionContext_brand, this, _onBindingCalled).bind(this));
-      clientEmitter.on('Runtime.executionContextDestroyed', async event => {
-        if (event.executionContextId === _classPrivateFieldGet(_id6, this)) {
+      if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] === '0') {
+        clientEmitter.on('Runtime.executionContextDestroyed', async event => {
+          if (event.executionContextId === _classPrivateFieldGet(_id6, this)) {
+            this[disposeSymbol]();
+          }
+        });
+        clientEmitter.on('Runtime.executionContextsCleared', async () => {
           this[disposeSymbol]();
-        }
-      });
-      clientEmitter.on('Runtime.executionContextsCleared', async () => {
-        this[disposeSymbol]();
-      });
+        });
+      }
       clientEmitter.on('Runtime.consoleAPICalled', _assertClassBrand(_ExecutionContext_brand, this, _onConsoleAPI).bind(this));
       clientEmitter.on(exports.CDPSessionEvent.Disconnected, () => {
         this[disposeSymbol]();
@@ -15586,6 +15437,146 @@
     async evaluateHandle(pageFunction, ...args) {
       return await _assertClassBrand(_ExecutionContext_brand, this, _evaluate).call(this, false, pageFunction, ...args);
     }
+    // rebrowser-patches: alternative to dispose
+    clear(newId) {
+      _classPrivateFieldSet(_id6, this, newId);
+      _classPrivateFieldSet(_bindings, this, new Map());
+      _classPrivateFieldSet(_bindingsInstalled, this, false);
+      _classPrivateFieldSet(_puppeteerUtil, this, undefined);
+    }
+    // rebrowser-patches: get context id if it's missing
+    async acquireContextId(tryCount = 1) {
+      if (_classPrivateFieldGet(_id6, this) > 0) {
+        return;
+      }
+      const fixMode = process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] || 'addBinding';
+      process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] id = ${_classPrivateFieldGet(_id6, this)}, name = ${_classPrivateFieldGet(_name3, this)}, fixMode = ${fixMode}, tryCount = ${tryCount}`);
+      let contextId;
+      if (fixMode === 'addBinding') {
+        try {
+          if (_classPrivateFieldGet(_id6, this) === -2) {
+            // isolated world
+            const sendRes = await _classPrivateFieldGet(_client8, this).send('Page.createIsolatedWorld', {
+              frameId: this._frameId,
+              worldName: _classPrivateFieldGet(_name3, this),
+              grantUniveralAccess: true
+            });
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] Page.createIsolatedWorld result:`, sendRes);
+            contextId = sendRes.executionContextId;
+          } else {
+            // main world
+            // random name to make it harder to detect for any 3rd party script by watching window object and events
+            const randomName = [...Array(Math.floor(Math.random() * (10 + 1)) + 10)].map(() => Math.random().toString(36)[2]).join('');
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] binding name = ${randomName}`);
+            // add the binding
+            await _classPrivateFieldGet(_client8, this).send('Runtime.addBinding', {
+              name: randomName
+            });
+            // listen for 'Runtime.bindingCalled' event
+            const bindingCalledHandler = ({
+              name,
+              payload,
+              executionContextId
+            }) => {
+              process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][bindingCalledHandler]', {
+                name,
+                payload,
+                executionContextId
+              });
+              if (contextId > 0) {
+                // already acquired the id
+                return;
+              }
+              if (name !== randomName) {
+                // ignore irrelevant bindings
+                return;
+              }
+              if (payload !== this._frameId) {
+                // ignore irrelevant frames
+                return;
+              }
+              contextId = executionContextId;
+              // remove this listener
+              _classPrivateFieldGet(_client8, this).off('Runtime.bindingCalled', bindingCalledHandler);
+            };
+            _classPrivateFieldGet(_client8, this).on('Runtime.bindingCalled', bindingCalledHandler);
+            // we could call the binding right from addScriptToEvaluateOnNewDocument, but this way it will be called in all existing frames and it's hard to distinguish children from the parent
+            await _classPrivateFieldGet(_client8, this).send('Page.addScriptToEvaluateOnNewDocument', {
+              source: `document.addEventListener('${randomName}', (e) => self['${randomName}'](e.detail.frameId))`,
+              runImmediately: true
+            });
+            // create new isolated world for this frame
+            const createIsolatedWorldRes = await _classPrivateFieldGet(_client8, this).send('Page.createIsolatedWorld', {
+              frameId: this._frameId,
+              // use randomName for worldName to distinguish from normal utility world
+              worldName: randomName,
+              grantUniveralAccess: true
+            });
+            // emit event in the specific frame from the isolated world
+            await _classPrivateFieldGet(_client8, this).send('Runtime.evaluate', {
+              expression: `document.dispatchEvent(new CustomEvent('${randomName}', { detail: { frameId: '${this._frameId}' } }))`,
+              contextId: createIsolatedWorldRes.executionContextId
+            });
+          }
+        } catch (error) {
+          process.env['REBROWSER_PATCHES_DEBUG'] && console.error('[rebrowser-patches][acquireContextId] error:', error);
+          if (error instanceof Error) {
+            // Missing frame
+            if (error.message.includes('No frame for given id found')) {
+              return;
+            }
+          }
+          debugError(error);
+        }
+      } else if (fixMode === 'alwaysIsolated') {
+        if (_classPrivateFieldGet(_id6, this) === -3) {
+          throw new Error('[rebrowser-patches] web workers are not supported in alwaysIsolated mode');
+        }
+        const sendRes = await _classPrivateFieldGet(_client8, this).send('Page.createIsolatedWorld', {
+          frameId: this._frameId,
+          worldName: _classPrivateFieldGet(_name3, this),
+          grantUniveralAccess: true
+        });
+        process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] Page.createIsolatedWorld result:`, sendRes);
+        contextId = sendRes.executionContextId;
+      } else if (fixMode === 'enableDisable') {
+        const executionContextCreatedHandler = ({
+          context
+        }) => {
+          process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][executionContextCreated] this.#id = ${_classPrivateFieldGet(_id6, this)}, name = ${_classPrivateFieldGet(_name3, this)}, contextId = ${contextId}, event.context.id = ${context.id}`);
+          if (contextId > 0) {
+            // already acquired the id
+            return;
+          }
+          if (_classPrivateFieldGet(_id6, this) === -1) {
+            // main world
+            if (context.auxData && context.auxData['isDefault']) {
+              contextId = context.id;
+            }
+          } else if (_classPrivateFieldGet(_id6, this) === -2) {
+            // utility world
+            if (_classPrivateFieldGet(_name3, this) === context.name) {
+              contextId = context.id;
+            }
+          } else if (_classPrivateFieldGet(_id6, this) === -3) {
+            // web worker
+            contextId = context.id;
+          }
+        };
+        _classPrivateFieldGet(_client8, this).on('Runtime.executionContextCreated', executionContextCreatedHandler);
+        await _classPrivateFieldGet(_client8, this).send('Runtime.enable');
+        await _classPrivateFieldGet(_client8, this).send('Runtime.disable');
+        _classPrivateFieldGet(_client8, this).off('Runtime.executionContextCreated', executionContextCreatedHandler);
+      }
+      if (!contextId) {
+        if (tryCount >= 3) {
+          throw new Error('[rebrowser-patches] acquireContextId failed');
+        }
+        process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] failed, try again (tryCount = ${tryCount})`);
+        return this.acquireContextId(tryCount + 1);
+      }
+      _classPrivateFieldSet(_id6, this, contextId);
+    }
     [disposeSymbol]() {
       _classPrivateFieldGet(_disposables, this).dispose();
       this.emit('disposed', undefined);
@@ -15686,6 +15677,12 @@
     }
   }
   async function _evaluate(returnByValue, pageFunction, ...args) {
+    // rebrowser-patches: context id is missing, acquire it and try again
+    if (_classPrivateFieldGet(_id6, this) < 0) {
+      await this.acquireContextId();
+      // @ts-ignore
+      return _assertClassBrand(_ExecutionContext_brand, this, _evaluate).call(this, returnByValue, pageFunction, ...args);
+    }
     const sourceUrlComment = getSourceUrlComment(getSourcePuppeteerURLIfAvailable(pageFunction)?.toString() ?? PuppeteerURL.INTERNAL_URL);
     if (isString(pageFunction)) {
       const contextId = _classPrivateFieldGet(_id6, this);
@@ -15847,6 +15844,27 @@
 
   /**
    * @license
+   * Copyright 2022 Google Inc.
+   * SPDX-License-Identifier: Apache-2.0
+   */
+  /**
+   * A unique key for {@link IsolatedWorldChart} to denote the default world.
+   * Execution contexts are automatically created in the default world.
+   *
+   * @internal
+   */
+  const MAIN_WORLD = Symbol('mainWorld');
+  /**
+   * A unique key for {@link IsolatedWorldChart} to denote the puppeteer world.
+   * This world contains all puppeteer-internal bindings/code.
+   *
+   * @internal
+   */
+  const PUPPETEER_WORLD = Symbol('puppeteerWorld');
+
+  //@ts-nocheck
+  /**
+   * @license
    * Copyright 2019 Google Inc.
    * SPDX-License-Identifier: Apache-2.0
    */
@@ -15920,6 +15938,8 @@
       if (!context) {
         context = await _assertClassBrand(_IsolatedWorld_brand, this, _waitForExecutionContext).call(this);
       }
+      // rebrowser-patches: make sure id is acquired
+      await context.acquireContextId();
       const {
         object
       } = await this.client.send('DOM.resolveNode', {
@@ -15975,15 +15995,9 @@
 
   /**
    * @license
-   * Copyright 2022 Google Inc.
+   * Copyright 2019 Google Inc.
    * SPDX-License-Identifier: Apache-2.0
    */
-  /**
-   * A unique key for {@link IsolatedWorldChart} to denote the default world.
-   * Execution contexts are automatically created in the default world.
-   *
-   * @internal
-   */
   function _onContextDisposed() {
     _classPrivateFieldSet(_context, this, undefined);
     if ('clearDocumentHandle' in _classPrivateFieldGet(_frameOrWorker, this)) {
@@ -16006,6 +16020,21 @@
    * Waits for the next context to be set on the isolated world.
    */
   async function _waitForExecutionContext() {
+    const fixMode = process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] || 'addBinding';
+    if (fixMode === 'addBinding') {
+      const isMainWorld = _classPrivateFieldGet(_frameOrWorker, this).worlds[MAIN_WORLD] === this;
+      process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][waitForExecutionContext] frameId = ${_classPrivateFieldGet(_frameOrWorker, this)._id}, isMainWorld = ${isMainWorld}`);
+      const contextPayload = {
+        id: isMainWorld ? -1 : -2,
+        name: isMainWorld ? '' : UTILITY_WORLD_NAME,
+        auxData: {
+          frameId: _classPrivateFieldGet(_frameOrWorker, this)._id
+        }
+      };
+      const context = new ExecutionContext(this.client, contextPayload, this);
+      this.setContext(context);
+      return context;
+    }
     const error = new Error('Execution context was destroyed');
     const result = await firstValueFrom(fromEmitterEvent(_classPrivateFieldGet(_emitter2, this), 'context').pipe(raceWith(fromEmitterEvent(_classPrivateFieldGet(_emitter2, this), 'disposed').pipe(map(() => {
       // The message has to match the CDP message expected by the WaitTask class.
@@ -16013,20 +16042,6 @@
     })), timeout(this.timeoutSettings.timeout()))));
     return result;
   }
-  const MAIN_WORLD = Symbol('mainWorld');
-  /**
-   * A unique key for {@link IsolatedWorldChart} to denote the puppeteer world.
-   * This world contains all puppeteer-internal bindings/code.
-   *
-   * @internal
-   */
-  const PUPPETEER_WORLD = Symbol('puppeteerWorld');
-
-  /**
-   * @license
-   * Copyright 2019 Google Inc.
-   * SPDX-License-Identifier: Apache-2.0
-   */
   const puppeteerToProtocolLifecycle = new Map([['load', 'load'], ['domcontentloaded', 'DOMContentLoaded'], ['networkidle0', 'networkIdle'], ['networkidle2', 'networkAlmostIdle']]);
   /**
    * @internal
@@ -17814,6 +17829,10 @@
         _assertClassBrand(_FrameManager_brand, this, _onFrameStoppedLoading).call(this, event.frameId);
       });
       session.on('Runtime.executionContextCreated', async event => {
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+          // rebrowser-patches: ignore default logic
+          return;
+        }
         await _classPrivateFieldGet(_frameTreeHandled, this)?.valueOrThrow();
         _assertClassBrand(_FrameManager_brand, this, _onExecutionContextCreated).call(this, event.context, session);
       });
@@ -17837,13 +17856,39 @@
           _classPrivateFieldGet(_frameTreeHandled, this)?.resolve();
         }), client.send('Page.setLifecycleEventsEnabled', {
           enabled: true
-        }), client.send('Runtime.enable').then(() => {
-          return _assertClassBrand(_FrameManager_brand, this, _createIsolatedWorld).call(this, client, UTILITY_WORLD_NAME);
-        }), ...(frame ? Array.from(_classPrivateFieldGet(_scriptsToEvaluateOnNewDocument, this).values()) : []).map(script => {
+        }), (() => {
+          // rebrowser-patches: skip Runtime.enable
+          if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][FrameManager] initialize');
+            return _assertClassBrand(_FrameManager_brand, this, _createIsolatedWorld).call(this, client, UTILITY_WORLD_NAME);
+          }
+          return client.send('Runtime.enable').then(() => {
+            return _assertClassBrand(_FrameManager_brand, this, _createIsolatedWorld).call(this, client, UTILITY_WORLD_NAME);
+          });
+        })(), ...(frame ? Array.from(_classPrivateFieldGet(_scriptsToEvaluateOnNewDocument, this).values()) : []).map(script => {
           return frame?.addPreloadScript(script);
         }), ...(frame ? Array.from(_classPrivateFieldGet(_bindings2, this).values()) : []).map(binding => {
           return frame?.addExposedFunctionBinding(binding);
         })]);
+        // rebrowser-patches: manually create main world context
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+          this.frames().filter(frame => {
+            return frame.client === client;
+          }).map(frame => {
+            const world = frame.worlds[MAIN_WORLD];
+            const contextPayload = {
+              id: -1,
+              name: '',
+              auxData: {
+                frameId: frame._id
+              }
+            };
+            const context = new ExecutionContext(frame.client,
+            // @ts-ignore
+            contextPayload, world);
+            world.setContext(context);
+          });
+        }
       } catch (error) {
         _classPrivateFieldGet(_frameTreeHandled, this)?.resolve();
         // The target might have been closed before the initialization finished.
@@ -18039,6 +18084,23 @@
       }
       this._frameTree.addFrame(frame);
     }
+    // rebrowser-patches: we cannot fully dispose contexts as they won't be recreated as we don't have Runtime events,
+    // instead, just mark it all empty
+    if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+      process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches] onFrameNavigated, navigationType = ${navigationType}, id = ${framePayload.id}, url = ${framePayload.url}`);
+      for (const worldSymbol of [MAIN_WORLD, PUPPETEER_WORLD]) {
+        // @ts-ignore
+        if (frame.worlds[worldSymbol].context) {
+          // @ts-ignore
+          const frameOrWorker = frame.worlds[worldSymbol].environment;
+          if ('clearDocumentHandle' in frameOrWorker) {
+            frameOrWorker.clearDocumentHandle();
+          }
+          // @ts-ignore
+          frame.worlds[worldSymbol].context?.clear(worldSymbol === MAIN_WORLD ? -1 : -2);
+        }
+      }
+    }
     frame = await this._frameTree.waitForFrame(frameId);
     frame._navigated(framePayload);
     this.emit(exports.FrameManagerEvent.FrameNavigated, frame);
@@ -18062,6 +18124,23 @@
         frameId: frame._id,
         worldName: name,
         grantUniveralAccess: true
+      }).then(createIsolatedWorldResult => {
+        // rebrowser-patches: save created context id
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] === '0') {
+          return;
+        }
+        if (!createIsolatedWorldResult?.executionContextId) {
+          // probably "Target closed" error, just ignore it
+          return;
+        }
+        // @ts-ignore
+        _assertClassBrand(_FrameManager_brand, this, _onExecutionContextCreated).call(this, {
+          id: createIsolatedWorldResult.executionContextId,
+          name,
+          auxData: {
+            frameId: frame._id
+          }
+        }, frame.client);
       }).catch(debugError);
     }));
     _classPrivateFieldGet(_isolatedWorlds, this).add(key);
@@ -20153,6 +20232,10 @@
       _classPrivateFieldSet(_targetType2, this, targetType);
       _classPrivateFieldSet(_world4, this, new IsolatedWorld(this, new TimeoutSettings()));
       _classPrivateFieldGet(_client17, this).once('Runtime.executionContextCreated', async event => {
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+          // rebrowser-patches: ignore default logic
+          return;
+        }
         _classPrivateFieldGet(_world4, this).setContext(new ExecutionContext(client, event.context, _classPrivateFieldGet(_world4, this)));
       });
       _classPrivateFieldGet(_world4, this).emitter.on('consoleapicalled', async event => {
@@ -20168,8 +20251,19 @@
       _classPrivateFieldGet(_client17, this).once(exports.CDPSessionEvent.Disconnected, () => {
         _classPrivateFieldGet(_world4, this).dispose();
       });
-      // This might fail if the target is closed before we receive all execution contexts.
-      _classPrivateFieldGet(_client17, this).send('Runtime.enable').catch(debugError);
+      if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+        // @ts-ignore
+        process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][WebWorker] initialize', targetType, targetId, client._target(), client._target()._getTargetInfo());
+        // rebrowser-patches: manually create context
+        const contextPayload = {
+          id: -3
+        };
+        // @ts-ignore
+        _classPrivateFieldGet(_world4, this).setContext(new ExecutionContext(client, contextPayload, _classPrivateFieldGet(_world4, this)));
+      } else {
+        // This might fail if the target is closed before we receive all execution contexts.
+        _classPrivateFieldGet(_client17, this).send('Runtime.enable').catch(debugError);
+      }
     }
     mainRealm() {
       return _classPrivateFieldGet(_world4, this);
@@ -21871,6 +21965,10 @@
     async newPage() {
       return await _classPrivateFieldGet(_defaultContext, this).newPage();
     }
+    // rebrowser-patches: expose browser CDP session
+    _connection() {
+      return _classPrivateFieldGet(_connection5, this);
+    }
     async _createPageInContext(contextId) {
       const {
         targetId

--- a/lib/esm/puppeteer/cdp/Browser.d.ts	
+++ b/lib/esm/puppeteer/cdp/Browser.d.ts	
@@ -31,6 +31,7 @@
     _disposeContext(contextId?: string): Promise<void>;
     wsEndpoint(): string;
     newPage(): Promise<Page>;
+    _connection(): Connection;
     _createPageInContext(contextId?: string): Promise<Page>;
     targets(): CdpTarget[];
     target(): CdpTarget;

--- a/lib/esm/puppeteer/cdp/Browser.js	
+++ b/lib/esm/puppeteer/cdp/Browser.js	
@@ -173,6 +173,10 @@
     async newPage() {
         return await this.#defaultContext.newPage();
     }
+    // rebrowser-patches: expose browser CDP session
+    _connection() {
+        return this.#connection;
+    }
     async _createPageInContext(contextId) {
         const { targetId } = await this.#connection.send('Target.createTarget', {
             url: 'about:blank',

--- a/lib/esm/puppeteer/cdp/ExecutionContext.d.ts	
+++ b/lib/esm/puppeteer/cdp/ExecutionContext.d.ts	
@@ -22,6 +22,7 @@
     bindingcalled: Protocol.Runtime.BindingCalledEvent;
 }> implements Disposable {
     #private;
+    _frameId: any;
     constructor(client: CDPSession, contextPayload: Protocol.Runtime.ExecutionContextDescription, world: IsolatedWorld);
     get id(): number;
     get puppeteerUtil(): Promise<JSHandle<PuppeteerUtil>>;
@@ -116,6 +117,8 @@
      * {@link ElementHandle | element handle}.
      */
     evaluateHandle<Params extends unknown[], Func extends EvaluateFunc<Params> = EvaluateFunc<Params>>(pageFunction: Func | string, ...args: Params): Promise<HandleFor<Awaited<ReturnType<Func>>>>;
+    clear(newId: any): void;
+    acquireContextId(tryCount?: number): Promise<any>;
     [disposeSymbol](): void;
 }
 //# sourceMappingURL=ExecutionContext.d.ts.map
\ No newline at end of file

--- a/lib/esm/puppeteer/cdp/ExecutionContext.js	
+++ b/lib/esm/puppeteer/cdp/ExecutionContext.js	
@@ -80,6 +80,7 @@
     #client;
     #world;
     #id;
+    _frameId;
     #name;
     #disposables = new DisposableStack();
     constructor(client, contextPayload, world) {
@@ -90,16 +91,22 @@
         if (contextPayload.name) {
             this.#name = contextPayload.name;
         }
+        // rebrowser-patches: keep frameId to use later
+        if (contextPayload.auxData?.frameId) {
+            this._frameId = contextPayload.auxData?.frameId;
+        }
         const clientEmitter = this.#disposables.use(new EventEmitter(this.#client));
         clientEmitter.on('Runtime.bindingCalled', this.#onBindingCalled.bind(this));
-        clientEmitter.on('Runtime.executionContextDestroyed', async (event) => {
-            if (event.executionContextId === this.#id) {
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] === '0') {
+            clientEmitter.on('Runtime.executionContextDestroyed', async (event) => {
+                if (event.executionContextId === this.#id) {
+                    this[disposeSymbol]();
+                }
+            });
+            clientEmitter.on('Runtime.executionContextsCleared', async () => {
                 this[disposeSymbol]();
-            }
-        });
-        clientEmitter.on('Runtime.executionContextsCleared', async () => {
-            this[disposeSymbol]();
-        });
+            });
+        }
         clientEmitter.on('Runtime.consoleAPICalled', this.#onConsoleAPI.bind(this));
         clientEmitter.on(CDPSessionEvent.Disconnected, () => {
             this[disposeSymbol]();
@@ -323,7 +330,154 @@
     async evaluateHandle(pageFunction, ...args) {
         return await this.#evaluate(false, pageFunction, ...args);
     }
+    // rebrowser-patches: alternative to dispose
+    clear(newId) {
+        this.#id = newId;
+        this.#bindings = new Map();
+        this.#bindingsInstalled = false;
+        this.#puppeteerUtil = undefined;
+    }
+    // rebrowser-patches: get context id if it's missing
+    async acquireContextId(tryCount = 1) {
+        if (this.#id > 0) {
+            return;
+        }
+        const fixMode = process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] || 'addBinding';
+        process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] id = ${this.#id}, name = ${this.#name}, fixMode = ${fixMode}, tryCount = ${tryCount}`);
+        let contextId;
+        if (fixMode === 'addBinding') {
+            try {
+                if (this.#id === -2) {
+                    // isolated world
+                    const sendRes = await this.#client.send('Page.createIsolatedWorld', {
+                        frameId: this._frameId,
+                        worldName: this.#name,
+                        grantUniveralAccess: true,
+                    });
+                    process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] Page.createIsolatedWorld result:`, sendRes);
+                    contextId = sendRes.executionContextId;
+                }
+                else {
+                    // main world
+                    // random name to make it harder to detect for any 3rd party script by watching window object and events
+                    const randomName = [...Array(Math.floor(Math.random() * (10 + 1)) + 10)].map(() => Math.random().toString(36)[2]).join('');
+                    process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] binding name = ${randomName}`);
+                    // add the binding
+                    await this.#client.send('Runtime.addBinding', {
+                        name: randomName,
+                    });
+                    // listen for 'Runtime.bindingCalled' event
+                    const bindingCalledHandler = ({ name, payload, executionContextId }) => {
+                        process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][bindingCalledHandler]', {
+                            name,
+                            payload,
+                            executionContextId
+                        });
+                        if (contextId > 0) {
+                            // already acquired the id
+                            return;
+                        }
+                        if (name !== randomName) {
+                            // ignore irrelevant bindings
+                            return;
+                        }
+                        if (payload !== this._frameId) {
+                            // ignore irrelevant frames
+                            return;
+                        }
+                        contextId = executionContextId;
+                        // remove this listener
+                        this.#client.off('Runtime.bindingCalled', bindingCalledHandler);
+                    };
+                    this.#client.on('Runtime.bindingCalled', bindingCalledHandler);
+                    // we could call the binding right from addScriptToEvaluateOnNewDocument, but this way it will be called in all existing frames and it's hard to distinguish children from the parent
+                    await this.#client.send('Page.addScriptToEvaluateOnNewDocument', {
+                        source: `document.addEventListener('${randomName}', (e) => self['${randomName}'](e.detail.frameId))`,
+                        runImmediately: true,
+                    });
+                    // create new isolated world for this frame
+                    const createIsolatedWorldRes = await this.#client.send('Page.createIsolatedWorld', {
+                        frameId: this._frameId,
+                        // use randomName for worldName to distinguish from normal utility world
+                        worldName: randomName,
+                        grantUniveralAccess: true,
+                    });
+                    // emit event in the specific frame from the isolated world
+                    await this.#client.send('Runtime.evaluate', {
+                        expression: `document.dispatchEvent(new CustomEvent('${randomName}', { detail: { frameId: '${this._frameId}' } }))`,
+                        contextId: createIsolatedWorldRes.executionContextId,
+                    });
+                }
+            }
+            catch (error) {
+                process.env['REBROWSER_PATCHES_DEBUG'] && console.error('[rebrowser-patches][acquireContextId] error:', error);
+                if (error instanceof Error) {
+                    // Missing frame
+                    if (error.message.includes('No frame for given id found')) {
+                        return;
+                    }
+                }
+                debugError(error);
+            }
+        }
+        else if (fixMode === 'alwaysIsolated') {
+            if (this.#id === -3) {
+                throw new Error('[rebrowser-patches] web workers are not supported in alwaysIsolated mode');
+            }
+            const sendRes = await this.#client
+                .send('Page.createIsolatedWorld', {
+                frameId: this._frameId,
+                worldName: this.#name,
+                grantUniveralAccess: true,
+            });
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] Page.createIsolatedWorld result:`, sendRes);
+            contextId = sendRes.executionContextId;
+        }
+        else if (fixMode === 'enableDisable') {
+            const executionContextCreatedHandler = ({ context }) => {
+                process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][executionContextCreated] this.#id = ${this.#id}, name = ${this.#name}, contextId = ${contextId}, event.context.id = ${context.id}`);
+                if (contextId > 0) {
+                    // already acquired the id
+                    return;
+                }
+                if (this.#id === -1) {
+                    // main world
+                    if (context.auxData && context.auxData['isDefault']) {
+                        contextId = context.id;
+                    }
+                }
+                else if (this.#id === -2) {
+                    // utility world
+                    if (this.#name === context.name) {
+                        contextId = context.id;
+                    }
+                }
+                else if (this.#id === -3) {
+                    // web worker
+                    contextId = context.id;
+                }
+            };
+            this.#client.on('Runtime.executionContextCreated', executionContextCreatedHandler);
+            await this.#client.send('Runtime.enable');
+            await this.#client.send('Runtime.disable');
+            this.#client.off('Runtime.executionContextCreated', executionContextCreatedHandler);
+        }
+        if (!contextId) {
+            if (tryCount >= 3) {
+                throw new Error('[rebrowser-patches] acquireContextId failed');
+            }
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] failed, try again (tryCount = ${tryCount})`);
+            return this.acquireContextId(tryCount + 1);
+        }
+        this.#id = contextId;
+    }
     async #evaluate(returnByValue, pageFunction, ...args) {
+        // rebrowser-patches: context id is missing, acquire it and try again
+        if (this.#id < 0) {
+            await this.acquireContextId();
+            // @ts-ignore
+            return this.#evaluate(returnByValue, pageFunction, ...args);
+        }
         const sourceUrlComment = getSourceUrlComment(getSourcePuppeteerURLIfAvailable(pageFunction)?.toString() ??
             PuppeteerURL.INTERNAL_URL);
         if (isString(pageFunction)) {

--- a/lib/esm/puppeteer/cdp/FrameManager.js	
+++ b/lib/esm/puppeteer/cdp/FrameManager.js	
@@ -147,6 +147,10 @@
             this.#onFrameStoppedLoading(event.frameId);
         });
         session.on('Runtime.executionContextCreated', async (event) => {
+            if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+                // rebrowser-patches: ignore default logic
+                return;
+            }
             await this.#frameTreeHandled?.valueOrThrow();
             this.#onExecutionContextCreated(event.context, session);
         });
@@ -171,9 +175,16 @@
                     this.#frameTreeHandled?.resolve();
                 }),
                 client.send('Page.setLifecycleEventsEnabled', { enabled: true }),
-                client.send('Runtime.enable').then(() => {
-                    return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);
-                }),
+                (() => {
+                    // rebrowser-patches: skip Runtime.enable
+                    if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+                        process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][FrameManager] initialize');
+                        return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);
+                    }
+                    return client.send('Runtime.enable').then(() => {
+                        return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);
+                    });
+                })(),
                 ...(frame
                     ? Array.from(this.#scriptsToEvaluateOnNewDocument.values())
                     : []).map(script => {
@@ -183,6 +194,26 @@
                     return frame?.addExposedFunctionBinding(binding);
                 }),
             ]);
+            // rebrowser-patches: manually create main world context
+            if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+                this.frames()
+                    .filter(frame => {
+                    return frame.client === client;
+                }).map(frame => {
+                    const world = frame.worlds[MAIN_WORLD];
+                    const contextPayload = {
+                        id: -1,
+                        name: '',
+                        auxData: {
+                            frameId: frame._id,
+                        }
+                    };
+                    const context = new ExecutionContext(frame.client, 
+                    // @ts-ignore
+                    contextPayload, world);
+                    world.setContext(context);
+                });
+            }
         }
         catch (error) {
             this.#frameTreeHandled?.resolve();
@@ -351,6 +382,23 @@
             }
             this._frameTree.addFrame(frame);
         }
+        // rebrowser-patches: we cannot fully dispose contexts as they won't be recreated as we don't have Runtime events,
+        // instead, just mark it all empty
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches] onFrameNavigated, navigationType = ${navigationType}, id = ${framePayload.id}, url = ${framePayload.url}`);
+            for (const worldSymbol of [MAIN_WORLD, PUPPETEER_WORLD]) {
+                // @ts-ignore
+                if (frame.worlds[worldSymbol].context) {
+                    // @ts-ignore
+                    const frameOrWorker = frame.worlds[worldSymbol].environment;
+                    if ('clearDocumentHandle' in frameOrWorker) {
+                        frameOrWorker.clearDocumentHandle();
+                    }
+                    // @ts-ignore
+                    frame.worlds[worldSymbol].context?.clear(worldSymbol === MAIN_WORLD ? -1 : -2);
+                }
+            }
+        }
         frame = await this._frameTree.waitForFrame(frameId);
         frame._navigated(framePayload);
         this.emit(FrameManagerEvent.FrameNavigated, frame);
@@ -378,6 +426,24 @@
                 worldName: name,
                 grantUniveralAccess: true,
             })
+                .then((createIsolatedWorldResult) => {
+                // rebrowser-patches: save created context id
+                if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] === '0') {
+                    return;
+                }
+                if (!createIsolatedWorldResult?.executionContextId) {
+                    // probably "Target closed" error, just ignore it
+                    return;
+                }
+                // @ts-ignore
+                this.#onExecutionContextCreated({
+                    id: createIsolatedWorldResult.executionContextId,
+                    name,
+                    auxData: {
+                        frameId: frame._id,
+                    }
+                }, frame.client);
+            })
                 .catch(debugError);
         }));
         this.#isolatedWorlds.add(key);

--- a/lib/esm/puppeteer/cdp/IsolatedWorld.d.ts	
+++ b/lib/esm/puppeteer/cdp/IsolatedWorld.d.ts	
@@ -12,9 +12,9 @@
 import type { TimeoutSettings } from '../common/TimeoutSettings.js';
 import type { EvaluateFunc, HandleFor } from '../common/types.js';
 import { disposeSymbol } from '../util/disposable.js';
-import type { ExecutionContext } from './ExecutionContext.js';
+import { ExecutionContext } from './ExecutionContext.js';
 import type { CdpFrame } from './Frame.js';
-import type { MAIN_WORLD, PUPPETEER_WORLD } from './IsolatedWorlds.js';
+import { MAIN_WORLD, PUPPETEER_WORLD } from './IsolatedWorlds.js';
 import type { CdpWebWorker } from './WebWorker.js';
 /**
  * @internal

--- a/lib/esm/puppeteer/cdp/IsolatedWorld.js	
+++ b/lib/esm/puppeteer/cdp/IsolatedWorld.js	
@@ -1,3 +1,4 @@
+//@ts-nocheck
 /**
  * @license
  * Copyright 2019 Google Inc.
@@ -6,9 +7,11 @@
 import { firstValueFrom, map, raceWith } from '../../third_party/rxjs/rxjs.js';
 import { Realm } from '../api/Realm.js';
 import { EventEmitter } from '../common/EventEmitter.js';
-import { fromEmitterEvent, timeout, withSourcePuppeteerURLIfNone, } from '../common/util.js';
+import { fromEmitterEvent, timeout, withSourcePuppeteerURLIfNone, UTILITY_WORLD_NAME, } from '../common/util.js';
 import { disposeSymbol } from '../util/disposable.js';
 import { CdpElementHandle } from './ElementHandle.js';
+import { ExecutionContext } from './ExecutionContext.js';
+import { MAIN_WORLD, PUPPETEER_WORLD } from './IsolatedWorlds.js';
 import { CdpJSHandle } from './JSHandle.js';
 /**
  * @internal
@@ -67,6 +70,21 @@
      * Waits for the next context to be set on the isolated world.
      */
     async #waitForExecutionContext() {
+        const fixMode = process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] || 'addBinding';
+        if (fixMode === 'addBinding') {
+            const isMainWorld = this.#frameOrWorker.worlds[MAIN_WORLD] === this;
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][waitForExecutionContext] frameId = ${this.#frameOrWorker._id}, isMainWorld = ${isMainWorld}`);
+            const contextPayload = {
+                id: isMainWorld ? -1 : -2,
+                name: isMainWorld ? '' : UTILITY_WORLD_NAME,
+                auxData: {
+                    frameId: this.#frameOrWorker._id,
+                }
+            };
+            const context = new ExecutionContext(this.client, contextPayload, this);
+            this.setContext(context);
+            return context;
+        }
         const error = new Error('Execution context was destroyed');
         const result = await firstValueFrom(fromEmitterEvent(this.#emitter, 'context').pipe(raceWith(fromEmitterEvent(this.#emitter, 'disposed').pipe(map(() => {
             // The message has to match the CDP message expected by the WaitTask class.
@@ -104,6 +122,8 @@
         if (!context) {
             context = await this.#waitForExecutionContext();
         }
+        // rebrowser-patches: make sure id is acquired
+        await context.acquireContextId();
         const { object } = await this.client.send('DOM.resolveNode', {
             backendNodeId: backendNodeId,
             executionContextId: context.id,

--- a/lib/esm/puppeteer/cdp/WebWorker.js	
+++ b/lib/esm/puppeteer/cdp/WebWorker.js	
@@ -21,6 +21,10 @@
         this.#targetType = targetType;
         this.#world = new IsolatedWorld(this, new TimeoutSettings());
         this.#client.once('Runtime.executionContextCreated', async (event) => {
+            if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+                // rebrowser-patches: ignore default logic
+                return;
+            }
             this.#world.setContext(new ExecutionContext(client, event.context, this.#world));
         });
         this.#world.emitter.on('consoleapicalled', async (event) => {
@@ -37,8 +41,20 @@
         this.#client.once(CDPSessionEvent.Disconnected, () => {
             this.#world.dispose();
         });
-        // This might fail if the target is closed before we receive all execution contexts.
-        this.#client.send('Runtime.enable').catch(debugError);
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+            // @ts-ignore
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][WebWorker] initialize', targetType, targetId, client._target(), client._target()._getTargetInfo());
+            // rebrowser-patches: manually create context
+            const contextPayload = {
+                id: -3,
+            };
+            // @ts-ignore
+            this.#world.setContext(new ExecutionContext(client, contextPayload, this.#world));
+        }
+        else {
+            // This might fail if the target is closed before we receive all execution contexts.
+            this.#client.send('Runtime.enable').catch(debugError);
+        }
     }
     mainRealm() {
         return this.#world;

--- a/lib/esm/puppeteer/common/util.js	
+++ b/lib/esm/puppeteer/common/util.js	
@@ -238,7 +238,10 @@
 /**
  * @internal
  */
-export const UTILITY_WORLD_NAME = '__puppeteer_utility_world__' + packageVersion;
+export const UTILITY_WORLD_NAME = 
+// rebrowser-patches: change utility world name
+process.env['REBROWSER_PATCHES_UTILITY_WORLD_NAME'] !== '0' ? (process.env['REBROWSER_PATCHES_UTILITY_WORLD_NAME'] || 'util') :
+    '__puppeteer_utility_world__' + packageVersion;
 /**
  * @internal
  */
@@ -247,6 +250,10 @@
  * @internal
  */
 export function getSourceUrlComment(url) {
+    // rebrowser-patches: change sourceUrl to generic script name
+    if (process.env['REBROWSER_PATCHES_SOURCE_URL'] !== '0') {
+        url = process.env['REBROWSER_PATCHES_SOURCE_URL'] || 'app.js';
+    }
     return `//# sourceURL=${url}`;
 }
 /**
